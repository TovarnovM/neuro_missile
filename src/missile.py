

class Missile(object):
    """Класс ракета, которая которая летает в двухмерном пространстве в поле силы тяжести и которой можно управлять) 
    
    Ракета имеет свои аэродинамические и массо- и тяговременные характеристики. Данные характеристики задаются 
    в виде простых констант и интерполированных таблиц (классов Interp1d и Interp2d в модуле invariants.py)
    
    Ракета имеет свое текущее положение и скорость ц.м. в пространстве, угол наклона оси ракеты к горизонту, угол атаки, 
    и угол атаки, к которому ракета стремится с определенной скоростью. Управление как раз и происходит путем выбора
    потребного угла атаки с определенной частотой. Множестов возможных потребыных углов атаки будем полагать дискретным.

    Класс предоставляет необходимые методы для моделироания динамики ракеты по времени

    Класс является мутабельным и представляет состояние ракеты на текущий момент времени. Класс не хранит историю 
    изменений сових параметров
    """
    # TODO сделать описание ММ ракеты для РПЗ (в ворде)

    @classmethod
    def get_needle(cls):
        """Классовый метод создания стандартной ракеты (иглы) со всеми необходимыми аэродинамическими, 
        массо- и тяговременными характеристиками

        returns Missile
        """
        # TODO реализовать метод
        pass

    @classmethod
    def get_standart_parametrs_of_missile(cls):
        """Возвращает словарь (или что там принимает метод set_init_cond) для стандартного начального состояния ракеты
        """
        # TODO реализовать метод
        pass

    def __init__(self, **kwargs):
        """Конструктор 
        """
        # TODO В зависимости от выбранной ММ определиться с выбором параметров, передаваемых в конструктор
        # Это обязательно должны быть аэродинамические, массо- и тяговременные характеристики. Задаются в виде констант
        # и объектов классов Interp1d и Interp2d
        # Сюда НЕ НАДО передавать начальные параметры ракеты, начальная инициализация будет в методе set_init_cond()
        pass

    def set_init_cond(self, parametrs_of_missile):
        """Задает начальные параметры (положение, скорость, углы ...) и запоминает их для того,
        чтобы потом в них можно было вернуться при помощи reset()
        
        Arguments:
            parametrs_of_missile 
        """
        # TODO реализовать
        pass

    def reset(self):
        """Возвращает ракету в начальное состояние
        """
        # TODO реализовать
        pass

    def get_state(self):
        """Метод получения вектора со всеми параметрами системы 
        (схож с вектором 'y' при интегрировании ode, но в вкеторе state еще одлжно быть t)

        return np.ndarray
        """
        # TODO реализовать
        pass

    def set_state(self, state):
        """Метод задания нового (может полностью отличающегося от текущего) состояния ракеты

        Arguments:
            state - np.ndarray  (схож с вектором 'y' при интегрировании ode, но в вкеторе state еще одлжно быть t)
        """
        # TODO реализовать метод
        pass   

    def _get_dydt(self, t, y):
        """Функция правых частей системы ОДУ динамики ракеты. 
        !!! Функция не должна зависеть от мутабельных параметров объекта !!!
        Т.е. значения всех дифференцируемых параметров должны браться из 'y'
        
        Arguments:
            t {float} -- время
            y {np.ndarray} -- вектор состояния системы 

        returns {np.ndarray} -- dy/dt
        """
        # TODO реализовать метод
        pass  


    def step(self, action, tau):
        """Моделирует динамику ракеты за шаг по времени tau. 
        На протяжении tau управляющее воздействие на ракету постоянно (action)
        Меняет внутреннее состояние ракеты на момент окончания шага
        
        Arguments:
            action {int} -- управляющее воздействие на протяжении шага
            tau {float} -- длина шага по времени (не путать с шагом интегрирования)
        """
        # TODO реализовать метод. Совет: объект ode(system_du) лучше заранее (в конструкторе) сохранить в отдельном поле объекта. 
        # Т.к. его создание и инициализация на каждом шаге дороговато стоят. 
        # Или еще проще реализовать свой простенький метод интегрирования <= ЛУЧШЕ ТАК
        pass

    @property
    def action_space(self):
        """Возвращает int'овый numpy-массив, элементы которого являются возможными действиями агента
        """
        # TODO реализовать свойство
        pass

    def action_sample(self):
        """Возвращает случайное возможное действие (int)
        """
        # TODO реализовать метод
        pass

    @property
    def pos(self):
        """Свойство, возвращающее текущее положение ц.м. ракеты в виде numpy массива из двух элементов 
        np.array([x,y])
        """
        # TODO реализовать метод.
        pass

    @property
    def vel(self):
        """Свойство, возвращающее текущий вектор скорости ракеты в виде numpy массива из двух элементов 
        np.array([Vx, Vy])
        """
        # TODO реализовать метод.
        pass   

    @property
    def x_axis(self):
        """Свойство, возвращающее текущий нормированный вектор центральной оси ракеты в виде numpy массива из двух элементов 
        np.array([Axi_x, Axi_y])
        """
        # TODO реализовать метод.
        pass   

    def get_summary(self):
        """Возвращает словарь с основными текущими параметрами и характеристиками ракеты в данный момент
        {
            't': ...,
            'P': ...,
            'V': ...,
            'x': ...,
            'y': ...,
            'Cx': ...,
            'Cy': ...,
            'alpha': ...,
            ...
        }
        """
        # TODO реализовать метод.
        pass   